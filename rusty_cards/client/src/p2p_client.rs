use colored::Colorize;
use log::{trace, warn};
use std::{
    io,
    net::{SocketAddr, TcpListener, TcpStream},
    option::Option,
    str::FromStr,
};

use crate::action::{self, Action};
use crate::game::{self, player::Side};
use crate::utils;
use rusty_cards::Handshake;

pub struct Client {
    server: SocketAddr,
    listener: TcpListener,
    going_first: bool,
}

impl Default for Client {
    fn default() -> Self {
        println!("Providing default values for client:");
        let server = Self::default_server();
        println!("Binding server address to: {}", server);
        let listener = Self::default_listener();
        println!("Binding your address to: {}", listener);
        Client {
            server,
            listener: TcpListener::bind(listener).unwrap(),
            going_first: false,
        }
    }
}

impl Client {
    pub fn new(server: SocketAddr, listener: SocketAddr) -> Self {
        println!("Binding server address to: {}", server);
        println!("Binding your address to: {}", listener);
        Client {
            server,
            listener: TcpListener::bind(listener).unwrap(),
            going_first: false,
        }
    }

    pub fn default_server() -> SocketAddr {
        trace!("Providing server's default address: 127.0.0.1:8888");
        SocketAddr::from_str("127.0.0.1:8888").unwrap()
    }

    pub fn default_listener() -> SocketAddr {
        trace!("Providing listener's default address: 127.0.0.1:8080");
        SocketAddr::from_str("127.0.0.1:8080").unwrap()
    }

    pub fn start(&mut self) -> io::Result<()> {
        println!("Looking for an opponent...");
        let mut game_state = game::GameState::new();
        let mut opponent_stream = if let Some(stream) = self.find_opponent(&mut game_state) {
            stream
        } else {
            panic!("Opponent stream is set to None. Unexpected behaviour!");
        };

        trace!("Ready to start the game");
        if self.going_first {
            println!("Starting the game...");
            let start_game: Action = Action::Start("Worthy opponent :3".to_string());
            match utils::send_msg(&mut opponent_stream, start_game) {
                Ok(()) => println!("Game begins!"),
                Err(e) => panic!("Connection failed, couldn't send the message\nError: {e}"),
            };
        } else {
            println!("Waiting for the opponent to start the game...");
            let mut buffer = [0; 1024];
            let num_bytes = utils::read_msg(&mut opponent_stream, &mut buffer);

            let game_begins: Action = match serde_json::from_slice(&buffer[..num_bytes]) {
                Ok(action) => action,
                Err(e) => panic!("Cannot parse the message!\n Error: {}", e),
            };

            match game_begins {
                Action::Start(greet) => println!("Game begins! {greet}"),
                _ => panic!("Connection failed"),
            };
        }
        trace!("Proceeding the game");
        self.proceed_game(opponent_stream, game_state);
        println!("The game ends :] GG");
        Ok(())
    }

    // Sends a message to a server with socket address
    // The response from the server is always one of the follwing:
    //      1. Wait, along with the password generated by the server
    //          It indicates that we should wait on a socket that we
    //          provided for the opponents message that will contain
    //          the password from the server
    //      2. Send, along with the opponents socket address and password
    //          It indicates that we should send a message with a password
    //          and the opponent will wait for this message on the socket
    //          address that we have received
    pub fn find_opponent(&mut self, game_state: &mut game::GameState) -> Option<TcpStream> {
        let mut server_stream = match TcpStream::connect(self.server) {
            Ok(stream) => stream,
            Err(e) => panic!("Couldn't connect to the server address.\nError: {}", e),
        };

        loop {
            println!("Sending my address to the server.");
            let listener_address = self.listener.local_addr().ok()?;
            let ready_msg = Handshake::Ready(listener_address);
            utils::send_msg(&mut server_stream, ready_msg).ok()?;

            println!("Waiting for an opponent...");
            let mut buffer = [0; 4096];
            let num_bytes = utils::read_msg(&mut server_stream, &mut buffer);

            println!("Opponent appeared. Trying to establish connection...");
            let server_response: Handshake = match serde_json::from_slice(&buffer[..num_bytes]) {
                Ok(handshake) => handshake,
                Err(e) => {
                    println!("Couldn't connect to the server address.\nError: {}", e);
                    Handshake::None
                }
            };

            match server_response {
                Handshake::Send(addr, password, gs) => match self.received_send(addr, password) {
                    Some(s) => {
                        *game_state = gs;
                        return Some(s);
                    }
                    None => continue,
                },
                Handshake::Wait(password, gs) => match self.received_wait(password) {
                    Some(s) => {
                        *game_state = gs;
                        return Some(s);
                    }
                    None => continue,
                },
                _ => {
                    println!("Incorrect message from server. Retrying to find opponent...");
                    continue;
                }
            }
        }
    }

    // Performs steps for the player who received Send message from the server
    pub fn received_send(&mut self, addr: SocketAddr, password: String) -> Option<TcpStream> {
        self.going_first = true; // This player goes first

        println!("Sending {password} to the {addr}, to establish connection.");
        let mut opponent_stream: TcpStream = match TcpStream::connect(addr) {
            Ok(stream) => stream,
            Err(e) => panic!("Couldn't connect to the given address.\nError: {}", e),
        };
        let msg = Handshake::P2P(password.clone());
        match utils::send_msg(&mut opponent_stream, msg) {
            Ok(()) => println!("Message sent successfully!"),
            Err(e) => {
                println!("Couldn't send the message due to error {e}. Retrying...");
                return None;
            }
        }

        println!("Waiting for the confirmation from the opponent...");
        let mut buffer = [0; 1024];
        let num_bytes = utils::read_msg(&mut opponent_stream, &mut buffer);

        let confirmation: Handshake = match serde_json::from_slice(&buffer[..num_bytes]) {
            Ok(handshake) => handshake,
            Err(e) => {
                println!("Couldn't connect to the server address.\nError: {}", e);
                Handshake::None
            }
        };
        if confirmation != Handshake::P2P(password) {
            println!("Faild to confirm the connection. Retrying to find opponent");
            return None;
        }

        println!("Connection established!");
        Some(opponent_stream)
    }

    // Performs steps for the player who received Wait message from the server
    pub fn received_wait(&mut self, password: String) -> Option<TcpStream> {
        self.going_first = false; // this player goes second

        println!("Waiting for the {password} to establish connection...");
        for stream in self.listener.incoming() {
            println!("New stream appeared!");
            let mut stream = if let Ok(s) = stream {
                s
            } else {
                continue;
            };
            let mut buffer = [0; 1024];
            let num_bytes = utils::read_msg(&mut stream, &mut buffer);

            let msg: Handshake = match serde_json::from_slice(&buffer[..num_bytes]) {
                Ok(handshake) => handshake,
                Err(e) => {
                    println!("Couldn't connect to the server address.\nError: {}", e);
                    Handshake::None
                }
            };
            if msg != Handshake::P2P(password.clone()) {
                println!("Unexpected message. Waiting for different stream.");
                continue;
            }
            println!("Received message from the opponent! Sending confirmation.");

            let confirmation: Handshake = Handshake::P2P(password);
            match utils::send_msg(&mut stream, confirmation) {
                Ok(()) => println!("Confirmation sent!"),
                Err(e) => {
                    println!(
                        "Couldn't send the confirmation due to error {e}. Retrying to find opponent"
                    );
                    return None;
                }
            }

            println!("Connection established!");
            return Some(stream);
        }
        None // Should never be reached
    }

    // Performs player's turn
    fn my_turn(
        &self,
        opponent_stream: &mut TcpStream,
        game_state: &mut game::GameState,
    ) -> (bool, Side) {
        let mut game_ends: bool = false;
        let mut winner = Side::Me;
        loop {
            let action = utils::provide_action();
            let action = action::perform_action(&mut game_ends, &mut winner, action, game_state);
            match action {
                Action::PlayCard(n1, n2) => {
                    game_state.display();
                    while utils::send_msg(opponent_stream, Action::PlayCard(n1, n2)).is_err() {
                        warn!("Sending an action to play a card failed");
                    }
                }
                Action::EndTurn => {
                    while utils::send_msg(opponent_stream, Action::EndTurn).is_err() {
                        warn!("Sending an action to end the turn failed");
                    }
                    game_state.display();
                    return (game_ends, winner);
                }
                _ => (),
            }
        }
    }

    // Perfmors opponent's turn
    fn opponent_turn(
        &self,
        opponent_stream: &mut TcpStream,
        game_state: &mut game::GameState,
    ) -> (bool, Side) {
        let mut game_ends: bool = false;
        let mut winner = Side::Me;
        loop {
            println!("Waiting for opponent's action");
            let mut buffer = [0; 1024];
            let num_bytes = utils::read_msg(opponent_stream, &mut buffer);

            let action: Action = match serde_json::from_slice(&buffer[..num_bytes]) {
                Ok(a) => a,
                Err(e) => panic!("Cannot parse the message!\n Error: {}", e),
            };
            let action = action::perform_action(&mut game_ends, &mut winner, action, game_state);

            match action {
                Action::PlayCard(_, _) => game_state.display(),
                Action::EndTurn => {
                    game_state.display();
                    return (game_ends, winner);
                }
                _ => (),
            }
        }
    }

    // Returns true if the game ends
    fn process_turn_result(game_ends: bool, winner: Side) -> bool {
        match game_ends {
            false => false,
            true => {
                match winner {
                    Side::Me => println!("{} ^u^", "You won!!!".bright_green()),
                    Side::Opponent => println!("{} *n*", "You lost".red()),
                };
                true
            }
        }
    }

    // Performs consecutive actions of the game until one of the players win
    fn proceed_game(&self, mut opponent_stream: TcpStream, mut game_state: game::GameState) {
        game_state.begin();
        game_state.display();

        if game_state.is_my_turn() {
            let (game_ends, winner) = self.my_turn(&mut opponent_stream, &mut game_state);
            if Self::process_turn_result(game_ends, winner) {
                return;
            }
        }

        loop {
            let (game_ends, winner) = self.opponent_turn(&mut opponent_stream, &mut game_state);
            if Self::process_turn_result(game_ends, winner) {
                return;
            }

            let (game_ends, winner) = self.my_turn(&mut opponent_stream, &mut game_state);
            if Self::process_turn_result(game_ends, winner) {
                return;
            }
        }
    }
}
